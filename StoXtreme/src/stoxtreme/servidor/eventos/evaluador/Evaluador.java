/*
 *  Generated By:JavaCC: Do not edit this line. Evaluador.java
 */
package stoxtreme.servidor.eventos.evaluador;
import java.io.*;
import java.util.*;

import stoxtreme.servidor.VariablesSistema;

/**
 *  Clase que evalúa si la condición tiene una sintaxis correcta
 *
 *@author    Iván Gómez Edo, Itziar Pérez García, Alonso Javier Torres
 */
public class Evaluador implements EvaluadorConstants {

	/**
	 *  Description of the Field
	 */
	public EvaluadorTokenManager token_source;
	/**
	 *  Description of the Field
	 */
	public Token token;
	/**
	 *  Description of the Field
	 */
	public Token jj_nt;
	SimpleCharStream jj_input_stream;
	// VARIABLES DEL PARSER
	private ArrayList variablesUsadas = new ArrayList();
	private VariablesSistema variables;
	private String condicion;
	private int jj_ntk;
	private int jj_gen;
	private final int[] jj_la1 = new int[10];

	private java.util.Vector jj_expentries = new java.util.Vector();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private static int[] jj_la1_0;


	/**
	 *  Constructor for the Evaluador object
	 *
	 *@param  s  Description of Parameter
	 */
	public Evaluador(String s) {
		this(new ByteArrayInputStream(s.getBytes()));
		this.condicion = s;
	}


	/**
	 *  Constructor for the Evaluador object
	 *
	 *@param  stream  Description of Parameter
	 */
	public Evaluador(java.io.InputStream stream) {
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new EvaluadorTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Constructor for the Evaluador object
	 *
	 *@param  stream  Description of Parameter
	 */
	public Evaluador(java.io.Reader stream) {
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new EvaluadorTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Constructor for the Evaluador object
	 *
	 *@param  tm  Description of Parameter
	 */
	public Evaluador(EvaluadorTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Gets the VariablesUsadas attribute of the Evaluador object
	 *
	 *@return    The VariablesUsadas value
	 */
	public ArrayList getVariablesUsadas() {
		return variablesUsadas;
	}


	/**
	 *  Gets the NextToken attribute of the Evaluador object
	 *
	 *@return    The NextToken value
	 */
	public final Token getNextToken() {
		if (token.next != null) {
			token = token.next;
		}
		else {
			token = token.next = token_source.getNextToken();
		}
		jj_ntk = -1;
		jj_gen++;
		return token;
	}


	/**
	 *  Gets the Token attribute of the Evaluador object
	 *
	 *@param  index  Description of Parameter
	 *@return        The Token value
	 */
	public final Token getToken(int index) {
		Token t = token;
		for (int i = 0; i < index; i++) {
			if (t.next != null) {
				t = t.next;
			}
			else {
				t = t.next = token_source.getNextToken();
			}
		}
		return t;
	}


	/**
	 *  Description of the Method
	 *
	 *@param  variables           Description of Parameter
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public boolean evalua(VariablesSistema variables) throws ParseException {
		ReInit(new ByteArrayInputStream(condicion.getBytes()));
		this.variables = variables;
		String[] ret = E0();
		compruebaTipo(ret[0], "boolean");
		return Boolean.parseBoolean(ret[1]);
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E0() throws ParseException {
		String[] ret1;
		String[] ret2;
		String[] ret = new String[2];
		ret1 = E1();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case OR:
				jj_consume_token(OR);
				ret2 = E0();
				compruebaTipo(ret1[0], "boolean");
				compruebaTipo(ret2[0], "boolean");
				ret[0] = "boolean";
				ret[1] = evalua("or", ret1[1], ret2[1]);
			{
				if (true) {
					return ret;
				}
			}
				break;
			default:
				jj_la1[0] = jj_gen;
				;
		}
		 {
			if (true) {
				return ret1;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E1() throws ParseException {
		String[] ret1;
		String[] ret2;
		String[] ret = new String[2];
		ret1 = E2();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case AND:
				jj_consume_token(AND);
				ret2 = E1();
				compruebaTipo(ret1[0], "boolean");
				compruebaTipo(ret2[0], "boolean");
				ret[0] = "boolean";
				ret[1] = evalua("and", ret1[1], ret2[1]);
			{
				if (true) {
					return ret;
				}
			}
				break;
			default:
				jj_la1[1] = jj_gen;
				;
		}
		 {
			if (true) {
				return ret1;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E2() throws ParseException {
		String op;
		String[] ret1;
		String[] ret2;
		String[] ret = new String[2];
		ret1 = E3();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case MENORIGUAL:
			case MAYORIGUAL:
			case IGUALDAD:
			case DISTINTO:
			case MENOR:
			case MAYOR:
				op = OpComp();
				ret2 = E2();
				compruebaTipo(ret1[0], "double");
				compruebaTipo(ret2[0], "double");
				ret[0] = "boolean";
				ret[1] = evalua(op, ret1[1], ret2[1]);
			{
				if (true) {
					return ret;
				}
			}
				break;
			default:
				jj_la1[2] = jj_gen;
				;
		}
		 {
			if (true) {
				return ret1;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String OpComp() throws ParseException {
		String s;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case MENORIGUAL:
				jj_consume_token(MENORIGUAL);
			{
				if (true) {
					return "menor_igual";
				}
			}
				break;
			case MAYORIGUAL:
				jj_consume_token(MAYORIGUAL);
			{
				if (true) {
					return "mayor_igual";
				}
			}
				break;
			case IGUALDAD:
				jj_consume_token(IGUALDAD);
			{
				if (true) {
					return "igual";
				}
			}
				break;
			case DISTINTO:
				jj_consume_token(DISTINTO);
			{
				if (true) {
					return "distinto";
				}
			}
				break;
			case MENOR:
				jj_consume_token(MENOR);
			{
				if (true) {
					return "menor";
				}
			}
				break;
			case MAYOR:
				jj_consume_token(MAYOR);
			{
				if (true) {
					return "mayor";
				}
			}
				break;
			default:
				jj_la1[3] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E3() throws ParseException {
		String op;
		String[] ret1;
		String[] ret2;
		String[] ret = new String[2];
		ret1 = E4();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case MAS:
			case MENOS:
				op = OpSum();
				ret2 = E3();
				compruebaTipo(ret1[0], "double");
				compruebaTipo(ret2[0], "double");
				ret[0] = "double";
				ret[1] = evalua(op, ret1[1], ret2[1]);
			{
				if (true) {
					return ret;
				}
			}
				break;
			default:
				jj_la1[4] = jj_gen;
				;
		}
		 {
			if (true) {
				return ret1;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String OpSum() throws ParseException {
		String s;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case MAS:
				jj_consume_token(MAS);
			{
				if (true) {
					return "suma";
				}
			}
				break;
			case MENOS:
				jj_consume_token(MENOS);
			{
				if (true) {
					return "resta";
				}
			}
				break;
			default:
				jj_la1[5] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E4() throws ParseException {
		String op;
		String[] ret1;
		String[] ret2;
		String[] ret = new String[2];
		ret1 = E5();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case POR:
			case ENTRE:
			case MOD:
				op = OpMul();
				ret2 = E4();
				compruebaTipo(ret1[0], "double");
				compruebaTipo(ret2[0], "double");
				ret[0] = "double";
				ret[1] = evalua(op, ret1[1], ret2[1]);
			{
				if (true) {
					return ret;
				}
			}
				break;
			default:
				jj_la1[6] = jj_gen;
				;
		}
		 {
			if (true) {
				return ret1;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String OpMul() throws ParseException {
		String s;
		Token t;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case POR:
				jj_consume_token(POR);
			{
				if (true) {
					return "multiplica";
				}
			}
				break;
			case ENTRE:
				jj_consume_token(ENTRE);
			{
				if (true) {
					return "divide";
				}
			}
				break;
			case MOD:
				jj_consume_token(MOD);
			{
				if (true) {
					return "modulo";
				}
			}
				break;
			default:
				jj_la1[7] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E5() throws ParseException {
		String[] ret1;
		String[] ret = new String[2];
		boolean not = false;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case NOT:
				jj_consume_token(NOT);
				not = true;
				break;
			default:
				jj_la1[8] = jj_gen;
				;
		}
		ret1 = E6();
		if (not) {
			compruebaTipo(ret1[0], "boolean");
			ret[0] = "boolean";
			ret[1] = evalua("not", ret1[1], "");
			 {
				if (true) {
					return ret;
				}
			}
		}
		 {
			 {
				if (true) {
					return ret1;
				}
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	public final String[] E6() throws ParseException {
		String[] ret = new String[2];
		Token t;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case PAP:
				jj_consume_token(PAP);
				ret = E0();
				jj_consume_token(PCI);
				break;
			case VAR:
				t = jj_consume_token(VAR);
				ret[0] = "double";
				if (!variables.hasVariable(t.image)) {
					if (true) {
						throw new ParseException("Error: No existe la variable " + t.image);
					}
				}
				ret[1] = variables.getValue(t.image).toString();
				variablesUsadas.add(t.image);
				break;
			case NUMERO:
				t = jj_consume_token(NUMERO);
				ret[0] = "double";
				ret[1] = t.image;
				break;
			case TRUE:
				jj_consume_token(TRUE);
				ret[0] = "boolean";
				ret[1] = "true";
				break;
			case FALSE:
				jj_consume_token(FALSE);
				ret[0] = "boolean";
				ret[1] = "false";
				break;
			default:
				jj_la1[9] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		 {
			if (true) {
				return ret;
			}
		}
		throw new Error("Missing return statement in function");
	}


	/**
	 *  Description of the Method
	 *
	 *@param  stream  Description of Parameter
	 */
	public void ReInit(java.io.InputStream stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  stream  Description of Parameter
	 */
	public void ReInit(java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  tm  Description of Parameter
	 */
	public void ReInit(EvaluadorTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) {
			jj_la1[i] = -1;
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@return    Description of the Returned Value
	 */
	public ParseException generateParseException() {
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[29];
		for (int i = 0; i < 29; i++) {
			la1tokens[i] = false;
		}
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 10; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 29; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement(jj_expentry);
			}
		}
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = (int[]) jj_expentries.elementAt(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}


	/**
	 *  Description of the Method
	 */
	public final void enable_tracing() {
	}


	/**
	 *  Description of the Method
	 */
	public final void disable_tracing() {
	}


	/**
	 *  Description of the Method
	 *
	 *@param  op   Description of Parameter
	 *@param  el1  Description of Parameter
	 *@param  el2  Description of Parameter
	 *@return      Description of the Returned Value
	 */
	private String evalua(String op, String el1, String el2) {
		if (op.equals("and")) {
			boolean b1 = Boolean.parseBoolean(el1);
			boolean b2 = Boolean.parseBoolean(el2);
			return Boolean.toString(b1 && b2);
		}
		else if (op.equals("or")) {
			boolean b1 = Boolean.parseBoolean(el1);
			boolean b2 = Boolean.parseBoolean(el2);
			return Boolean.toString(b1 || b2);
		}
		else if (op.equals("multiplica")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Double.toString(d1 * d2);
		}
		else if (op.equals("divide")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Double.toString(d1 / d2);
		}
		else if (op.equals("modulo")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Double.toString(d1 % d2);
		}
		else if (op.equals("suma")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Double.toString(d1 + d2);
		}
		else if (op.equals("resta")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Double.toString(d1 - d2);
		}
		else if (op.equals("mayor")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 > d2);
		}
		else if (op.equals("menor")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 < d2);
		}
		else if (op.equals("mayor_igual")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 >= d2);
		}
		else if (op.equals("menor_igual")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 <= d2);
		}
		else if (op.equals("igual")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 == d2);
		}
		else if (op.equals("distinto")) {
			double d1 = Double.parseDouble(el1);
			double d2 = Double.parseDouble(el2);
			return Boolean.toString(d1 != d2);
		}
		else {
			//if(op.equals("not"){
			boolean b1 = Boolean.parseBoolean(el1);
			return Boolean.toString(!b1);
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  valor               Description of Parameter
	 *@param  tipo                Description of Parameter
	 *@exception  ParseException  Description of Exception
	 */
	private void compruebaTipo(String valor, String tipo) throws ParseException {
		if (!valor.equals(tipo)) {
			throw new ParseException("Error de tipo: esperado " + tipo);
		}
	}


	/**
	 *  Description of the Method
	 *
	 *@param  kind                Description of Parameter
	 *@return                     Description of the Returned Value
	 *@exception  ParseException  Description of Exception
	 */
	private final Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null) {
			token = token.next;
		}
		else {
			token = token.next = token_source.getNextToken();
		}
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}


	/**
	 *  Description of the Method
	 *
	 *@return    Description of the Returned Value
	 */
	private final int jj_ntk() {
		if ((jj_nt = token.next) == null) {
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		}
		else {
			return (jj_ntk = jj_nt.kind);
		}
	}


	/**
	 *  Description of the Method
	 */
	private static void jj_la1_0() {
		jj_la1_0 = new int[]{0x40, 0x20, 0x1f800, 0x1f800, 0x180000, 0x180000, 0x260000, 0x260000, 0x400000, 0x1800380,};
	}
	static {
		jj_la1_0();
	}

}
